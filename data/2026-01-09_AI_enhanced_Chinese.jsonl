{"id": "2601.04432", "categories": ["cs.DB"], "pdf": "https://arxiv.org/pdf/2601.04432", "abs": "https://arxiv.org/abs/2601.04432", "authors": ["Harshavardhan Kamarthi", "Harshil Shah", "Henry Milner", "Sayan Sinha", "Yan Li", "B. Aditya Prakash", "Vyas Sekar"], "title": "AHA: Scalable Alternative History Analysis for Operational Timeseries Applications", "comment": "To Appear at KDD 2026", "summary": "Many operational systems collect high-dimensional timeseries data about users/systems on key performance metrics. For instance, ISPs, content distribution networks, and video delivery services collect quality of experience metrics for user sessions associated with metadata (e.g., location, device, ISP). Over such historical data, operators and data analysts often need to run retrospective analysis; e.g., analyze anomaly detection algorithms, experiment with different configurations for alerts, evaluate new algorithms, and so on. We refer to this class of workloads as alternative history analysis for operational datasets. We show that in such settings, traditional data processing solutions (e.g., data warehouses, sampling, sketching, big-data systems) either pose high operational costs or do not guarantee accurate replay. We design and implement a system, called AHA (Alternative History Analytics), that overcomes both challenges to provide cost efficiency and fidelity for high-dimensional data. The design of AHA is based on analytical and empirical insights about such workloads: 1) the decomposability of underlying statistics; 2) sparsity in terms of active number of subpopulations over attribute-value combinations; and 3) efficiency structure of aggregation operations in modern analytics databases. Using multiple real-world datasets and as well as case-studies on production pipelines at a large video analytics company, we show that AHA provides 100% accuracy for a broad range of downstream tasks and up to 85x lower total cost of ownership (i.e., compute + storage) compared to conventional methods.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u540d\u4e3aAHA\uff08Alternative History Analytics\uff09\u7684\u7cfb\u7edf\uff0c\u7528\u4e8e\u9ad8\u6548\u4e14\u7cbe\u786e\u5730\u5bf9\u9ad8\u7ef4\u8fd0\u7ef4\u65f6\u5e8f\u6570\u636e\u8fdb\u884c\u201c\u66ff\u4ee3\u5386\u53f2\u5206\u6790\u201d\uff08\u5982\u56de\u6eaf\u6027\u5f02\u5e38\u68c0\u6d4b\u3001\u544a\u8b66\u914d\u7f6e\u5b9e\u9a8c\u7b49\uff09\u3002\u76f8\u6bd4\u4f20\u7edf\u65b9\u6848\uff08\u5982\u6570\u636e\u4ed3\u5e93\u3001\u91c7\u6837\u3001\u5927\u6570\u636e\u7cfb\u7edf\uff09\uff0cAHA\u5728\u4fdd\u8bc1100%\u5206\u6790\u51c6\u786e\u7387\u7684\u540c\u65f6\uff0c\u53ef\u5c06\u603b\u62e5\u6709\u6210\u672c\uff08\u8ba1\u7b97+\u5b58\u50a8\uff09\u964d\u4f4e\u9ad8\u8fbe85\u500d\u3002", "motivation": "\u8fd0\u7ef4\u7cfb\u7edf\uff08\u5982ISP\u3001CDN\u3001\u89c6\u9891\u670d\u52a1\uff09\u5e38\u9700\u5bf9\u5305\u542b\u4e30\u5bcc\u5143\u6570\u636e\u7684\u9ad8\u7ef4\u65f6\u5e8f\u6027\u80fd\u6307\u6807\u8fdb\u884c\u56de\u6eaf\u6027\u5206\u6790\uff08\u5982\u8bc4\u4f30\u5f02\u5e38\u68c0\u6d4b\u7b97\u6cd5\u3001\u6d4b\u8bd5\u544a\u8b66\u914d\u7f6e\u7b49\uff09\uff0c\u4f5c\u8005\u5c06\u6b64\u7c7b\u8d1f\u8f7d\u79f0\u4e3a\u201c\u66ff\u4ee3\u5386\u53f2\u5206\u6790\u201d\u3002\u7136\u800c\uff0c\u73b0\u6709\u6570\u636e\u5904\u7406\u65b9\u6848\u5728\u6b64\u7c7b\u573a\u666f\u4e0b\u9762\u4e34\u9ad8\u6602\u8fd0\u8425\u6210\u672c\u6216\u65e0\u6cd5\u4fdd\u8bc1\u91cd\u653e\u51c6\u786e\u6027\u7684\u95ee\u9898\u3002", "method": "AHA\u7cfb\u7edf\u7684\u8bbe\u8ba1\u57fa\u4e8e\u4e09\u65b9\u9762\u6d1e\u5bdf\uff1a1\uff09\u5e95\u5c42\u7edf\u8ba1\u91cf\u7684\u53ef\u5206\u89e3\u6027\uff1b2\uff09\u5c5e\u6027-\u503c\u7ec4\u5408\u6240\u5b9a\u4e49\u7684\u5b50\u7fa4\u4f53\u5728\u6d3b\u8dc3\u6570\u91cf\u4e0a\u7684\u7a00\u758f\u6027\uff1b3\uff09\u73b0\u4ee3\u5206\u6790\u6570\u636e\u5e93\u4e2d\u805a\u5408\u64cd\u4f5c\u7684\u9ad8\u6548\u7ed3\u6784\u3002\u5229\u7528\u8fd9\u4e9b\u7279\u6027\uff0cAHA\u5b9e\u73b0\u4e86\u517c\u987e\u6210\u672c\u6548\u76ca\u4e0e\u4fdd\u771f\u5ea6\u7684\u9ad8\u7ef4\u6570\u636e\u5904\u7406\u3002", "result": "\u5728\u591a\u4e2a\u771f\u5b9e\u4e16\u754c\u6570\u636e\u96c6\u53ca\u4e00\u5bb6\u5927\u578b\u89c6\u9891\u5206\u6790\u516c\u53f8\u7684\u751f\u4ea7\u7ba1\u9053\u6848\u4f8b\u7814\u7a76\u4e2d\uff0cAHA\u5728\u5e7f\u6cdb\u7684\u4e0b\u6e38\u4efb\u52a1\u4e2d\u5b9e\u73b0\u4e86100%\u7684\u51c6\u786e\u6027\uff0c\u5e76\u5c06\u603b\u62e5\u6709\u6210\u672c\uff08\u8ba1\u7b97+\u5b58\u50a8\uff09\u964d\u4f4e\u4e86\u9ad8\u8fbe85\u500d\u3002", "conclusion": "AHA\u7cfb\u7edf\u901a\u8fc7\u5229\u7528\u66ff\u4ee3\u5386\u53f2\u5206\u6790\u5de5\u4f5c\u8d1f\u8f7d\u7684\u72ec\u7279\u7279\u6027\uff0c\u6210\u529f\u89e3\u51b3\u4e86\u4f20\u7edf\u65b9\u6cd5\u5728\u6210\u672c\u548c\u51c6\u786e\u6027\u4e0a\u7684\u6743\u8861\u95ee\u9898\uff0c\u4e3a\u9ad8\u7ef4\u8fd0\u7ef4\u6570\u636e\u7684\u56de\u6eaf\u6027\u5206\u6790\u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ad8\u6548\u4e14\u7cbe\u786e\u7684\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2601.04757", "categories": ["cs.DB", "cs.LO"], "pdf": "https://arxiv.org/pdf/2601.04757", "abs": "https://arxiv.org/abs/2601.04757", "authors": ["Cristian Riveros", "Benjamin Scheidt", "Nicole Schweikardt"], "title": "Structural Indexing of Relational Databases for the Evaluation of Free-Connex Acyclic Conjunctive Queries", "comment": "This paper supersedes the preprint arXiv:2405.12358 by the same authors that only considered the special case of binary schemas", "summary": "We present an index structure to boost the evaluation of free-connex acyclic conjunctive queries (fc-ACQs) over relational databases. The main ingredient of the index associated with a given database $D$ is an auxiliary database $D_{col}$. Our main result states that for any fc-ACQ $Q$ over $D$, we can count the number of answers of $Q$ or enumerate them with constant delay after a preprocessing phase that takes time linear in the size of $D_{col}$.\n  Unlike previous indexing methods based on values or order (e.g., B+ trees), our index is based on structural symmetries among tuples in a database, and the size of $D_{col}$ is related to the number of colors assigned to $D$ by Scheidt and Schweikardt's \"relational color refinement\" (2025). In the particular case of graphs, this coincides with the minimal size of an equitable partition of the graph. For example, the size of $D_{col}$ is logarithmic in the case of binary trees and constant for regular graphs. Even in the worst-case that $D$ has no structural symmetries among tuples at all, the size of $D_{col}$ is still linear in the size of $D$.\n  Given that the size of $D_{col}$ is bounded by the size of $D$ and can be much smaller (even constant for some families of databases), our index is the first foundational result on indexing internal structural symmetries of a database to evaluate all fc-ACQs with performance potentially strictly smaller than the database size.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u6570\u636e\u5e93\u5185\u90e8\u7ed3\u6784\u5bf9\u79f0\u6027\u7684\u65b0\u578b\u7d22\u5f15\u7ed3\u6784\uff0c\u901a\u8fc7\u6784\u5efa\u8f85\u52a9\u6570\u636e\u5e93 $D_{col}$\uff0c\u53ef\u5728\u9884\u5904\u7406\u65f6\u95f4\u4e0e $D_{col}$ \u5927\u5c0f\u6210\u7ebf\u6027\u5173\u7cfb\u7684\u524d\u63d0\u4e0b\uff0c\u5bf9\u4efb\u610f\u81ea\u7531\u8fde\u63a5\u65e0\u73af\u5408\u53d6\u67e5\u8be2\uff08fc-ACQ\uff09\u5b9e\u73b0\u5e38\u6570\u5ef6\u8fdf\u679a\u4e3e\u6216\u8ba1\u6570\u3002\u8be5\u7d22\u5f15\u5229\u7528\u5173\u7cfb\u7740\u8272\u7cbe\u5316\uff08relational color refinement\uff09\u6280\u672f\uff0c\u5176\u5927\u5c0f\u5728\u8bb8\u591a\u60c5\u51b5\u4e0b\u8fdc\u5c0f\u4e8e\u539f\u59cb\u6570\u636e\u5e93\uff0c\u751a\u81f3\u53ef\u4e3a\u5e38\u6570\u3002", "motivation": "\u4f20\u7edf\u7d22\u5f15\u65b9\u6cd5\uff08\u5982B+\u6811\uff09\u4f9d\u8d56\u503c\u6216\u987a\u5e8f\u4fe1\u606f\uff0c\u65e0\u6cd5\u6709\u6548\u5229\u7528\u6570\u636e\u5e93\u4e2d\u5143\u7ec4\u95f4\u7684\u7ed3\u6784\u5bf9\u79f0\u6027\u3002\u4f5c\u8005\u65e8\u5728\u5f00\u53d1\u4e00\u79cd\u80fd\u6355\u6349\u5e76\u5229\u7528\u8fd9\u4e9b\u5185\u90e8\u7ed3\u6784\u5bf9\u79f0\u6027\u7684\u7d22\u5f15\u673a\u5236\uff0c\u4ee5\u63d0\u5347fc-ACQ\u67e5\u8be2\u7684\u8bc4\u4f30\u6548\u7387\uff0c\u7279\u522b\u662f\u5728\u9884\u5904\u7406\u548c\u67e5\u8be2\u5ef6\u8fdf\u65b9\u9762\u53d6\u5f97\u4f18\u4e8e\u6570\u636e\u5e93\u89c4\u6a21\u7684\u6027\u80fd\u3002", "method": "\u4f5c\u8005\u4e3a\u7ed9\u5b9a\u6570\u636e\u5e93 $D$ \u6784\u5efa\u4e00\u4e2a\u8f85\u52a9\u6570\u636e\u5e93 $D_{col}$\uff0c\u5176\u6784\u9020\u57fa\u4e8eScheidt\u548cSchweikardt\uff082025\uff09\u63d0\u51fa\u7684\u201c\u5173\u7cfb\u7740\u8272\u7cbe\u5316\u201d\u65b9\u6cd5\u3002\u8be5\u65b9\u6cd5\u901a\u8fc7\u5bf9\u6570\u636e\u5e93\u5143\u7ec4\u8fdb\u884c\u7740\u8272\u4ee5\u8bc6\u522b\u7ed3\u6784\u5bf9\u79f0\u6027\uff0c$D_{col}$ \u7684\u5927\u5c0f\u7b49\u4e8e\u7740\u8272\u540e\u7684\u989c\u8272\u6570\u91cf\u3002\u5229\u7528\u8be5\u7d22\u5f15\uff0c\u53ef\u5728 $O(|D_{col}|)$ \u9884\u5904\u7406\u65f6\u95f4\u5185\uff0c\u5bf9\u4efb\u610ffc-ACQ\u5b9e\u73b0\u7b54\u6848\u8ba1\u6570\u6216\u5e38\u6570\u5ef6\u8fdf\u679a\u4e3e\u3002", "result": "\u8be5\u65b9\u6cd5\u5728\u591a\u79cd\u6570\u636e\u5e93\u7ed3\u6784\u4e0a\u5c55\u73b0\u51fa\u663e\u8457\u4f18\u52bf\uff1a\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e8c\u53c9\u6811\uff0c$D_{col}$ \u7684\u5927\u5c0f\u4e3a\u5bf9\u6570\u7ea7\uff1b\u5bf9\u4e8e\u6b63\u5219\u56fe\uff0c\u5176\u5927\u5c0f\u4e3a\u5e38\u6570\u3002\u5373\u4f7f\u5728\u6700\u574f\u60c5\u51b5\u4e0b\uff08\u65e0\u4efb\u4f55\u7ed3\u6784\u5bf9\u79f0\u6027\uff09\uff0c$D_{col}$ \u7684\u5927\u5c0f\u4ecd\u4e3a $O(|D|)$\u3002\u56e0\u6b64\uff0c\u8fd9\u662f\u9996\u4e2a\u5229\u7528\u6570\u636e\u5e93\u5185\u90e8\u7ed3\u6784\u5bf9\u79f0\u6027\u5b9e\u73b0\u4f18\u4e8e\u6570\u636e\u5e93\u89c4\u6a21\u67e5\u8be2\u6027\u80fd\u7684\u57fa\u7840\u6027\u7d22\u5f15\u7ed3\u679c\u3002", "conclusion": "\u672c\u6587\u63d0\u51fa\u7684\u57fa\u4e8e\u7ed3\u6784\u5bf9\u79f0\u6027\u7684\u7d22\u5f15\u7ed3\u6784\u4e3a\u9ad8\u6548\u8bc4\u4f30fc-ACQ\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b0\u8303\u5f0f\uff0c\u5176\u6027\u80fd\u53d6\u51b3\u4e8e\u6570\u636e\u5e93\u7684\u5185\u5728\u5bf9\u79f0\u6027\u800c\u975e\u5176\u7edd\u5bf9\u89c4\u6a21\uff0c\u5728\u7406\u8bba\u548c\u5b9e\u8df5\u4e0a\u5747\u5177\u6709\u91cd\u8981\u610f\u4e49\u3002"}}
{"id": "2601.04820", "categories": ["cs.DB", "cs.SI"], "pdf": "https://arxiv.org/pdf/2601.04820", "abs": "https://arxiv.org/abs/2601.04820", "authors": ["Chotanansub Sophaken", "Thanadej Rattanakornphan", "Piyanon Charoenpoonpanich", "Thanapol Phungtua-eng", "Chainarong Amornbunchornvej"], "title": "LGTD: Local-Global Trend Decomposition for Season-Length-Free Time Series Analysis", "comment": "First draft", "summary": "Time series decomposition into trend, seasonal structure, and residual components is a core primitive for downstream analytics such as anomaly detection, change-point detection, and forecasting. However, most existing seasonal-trend decomposition methods rely on user-specified or estimated season lengths and implicitly assume stable periodic structure. These assumptions limit robustness and deployability in large, heterogeneous collections where recurring patterns may drift, appear intermittently, or exist at multiple time scales.\n  We propose LGTD (Local-Global Trend Decomposition), a season-length-free decomposition framework that represents a time series as the sum of a smooth global trend, adaptive local trends whose recurrence induces implicit (emergent) seasonal structure, and a residual component. Rather than explicitly modeling seasonality through a fixed or estimated period, LGTD treats seasonal structure as an emergent property arising from repeated local trend regimes. Concretely, LGTD first estimates a global trend capturing long-term evolution, then applies AutoTrend, an adaptive error-driven local linear trend inference module, to segment the detrended signal into short-lived piecewise-linear regimes. Residuals are obtained after removing both global and local trends.\n  By eliminating manual season-length specification, LGTD supports automated, low-touch deployment across time series with irregular, drifting, or weakly periodic structure. We analyze computational complexity and show that LGTD scales linearly with series length under mild conditions. Experiments on synthetic benchmarks demonstrate robust and balanced decomposition performance across fixed, transitive, and variable season-length settings, especially where period-based methods degrade.", "AI": {"tldr": "LGTD is a season-length-free time series decomposition method that models seasonal patterns as emergent from adaptive local trends, eliminating the need for predefined or estimated season lengths and improving robustness in heterogeneous and drifting periodic settings.", "motivation": "Existing seasonal-trend decomposition methods often require user-specified or estimated season lengths and assume stable periodicity, which limits their robustness and applicability to real-world time series with irregular, drifting, or multi-scale recurring patterns.", "method": "LGTD decomposes a time series into a smooth global trend, adaptive local trends (via an error-driven module called AutoTrend that segments the detrended signal into piecewise-linear regimes), and a residual. Seasonality emerges implicitly from repeated local trend structures rather than being explicitly modeled with fixed periods.", "result": "Experiments on synthetic benchmarks show LGTD achieves robust and balanced decomposition performance across scenarios with fixed, transitive, and variable season lengths\u2014particularly outperforming period-based methods when periodicity is unstable or weak. The method scales linearly with time series length under mild conditions.", "conclusion": "LGTD provides a practical, automated decomposition framework that enhances deployability in large, heterogeneous time series collections by removing reliance on explicit season-length specification and adapting to complex temporal structures."}}
{"id": "2601.05108", "categories": ["cs.DB", "cs.LO"], "pdf": "https://arxiv.org/pdf/2601.05108", "abs": "https://arxiv.org/abs/2601.05108", "authors": ["Philipp Hanisch", "Markus Kr\u00f6tzsch"], "title": "Rule Rewriting Revisited: A Fresh Look at Static Filtering for Datalog and ASP", "comment": "Technical report of our ICDT'26 paper", "summary": "Static filtering is a data-independent optimisation method for Datalog, which generalises algebraic query rewriting techniques from relational databases. In spite of its early discovery by Kifer and Lozinskii in 1986, the method has been overlooked in recent research and system development, and special cases are being rediscovered independently. We therefore recall the original approach, using updated terminology and more general filter predicates that capture features of modern systems, and we show how to extend its applicability to answer set programming (ASP). The outcome is strictly more general but also more complex than the classical approach: double exponential in general and single exponential even for predicates of bounded arity. As a solution, we propose tractable approximations of the algorithm that can still yield much improved logic programs in typical cases, e.g., it can improve the performance of rule systems over real-world data in the order of magnitude.", "AI": {"tldr": "\u8be5\u8bba\u6587\u91cd\u65b0\u5ba1\u89c6\u5e76\u63a8\u5e7f\u4e86Kifer\u548cLozinskii\u4e8e1986\u5e74\u63d0\u51fa\u7684\u9759\u6001\u8fc7\u6ee4\u65b9\u6cd5\uff0c\u5c06\u5176\u6269\u5c55\u81f3\u73b0\u4ee3Datalog\u7cfb\u7edf\u53ca\u56de\u7b54\u96c6\u7f16\u7a0b\uff08ASP\uff09\uff0c\u5c3d\u7ba1\u5176\u901a\u7528\u5f62\u5f0f\u5177\u6709\u53cc\u6307\u6570\u590d\u6742\u5ea6\uff0c\u4f46\u4f5c\u8005\u63d0\u51fa\u4e86\u53ef\u5904\u7406\u7684\u8fd1\u4f3c\u7b97\u6cd5\uff0c\u5728\u5178\u578b\u573a\u666f\u4e2d\u4ecd\u80fd\u663e\u8457\u63d0\u5347\u89c4\u5219\u7cfb\u7edf\u7684\u6027\u80fd\u3002", "motivation": "\u9759\u6001\u8fc7\u6ee4\u4f5c\u4e3a\u4e00\u79cd\u6570\u636e\u65e0\u5173\u7684Datalog\u4f18\u5316\u65b9\u6cd5\uff0c\u867d\u65e9\u57281986\u5e74\u5c31\u88ab\u63d0\u51fa\uff0c\u4f46\u5728\u8fd1\u671f\u7814\u7a76\u4e0e\u7cfb\u7edf\u5f00\u53d1\u4e2d\u88ab\u5ffd\u89c6\uff0c\u4e14\u5176\u7279\u4f8b\u88ab\u53cd\u590d\u72ec\u7acb\u91cd\u65b0\u53d1\u73b0\u3002\u56e0\u6b64\uff0c\u6709\u5fc5\u8981\u4ee5\u73b0\u4ee3\u672f\u8bed\u91cd\u65b0\u9610\u8ff0\u8be5\u65b9\u6cd5\uff0c\u5e76\u62d3\u5c55\u5176\u9002\u7528\u8303\u56f4\u3002", "method": "\u4f5c\u8005\u4f7f\u7528\u66f4\u65b0\u7684\u672f\u8bed\u548c\u66f4\u901a\u7528\u7684\u8fc7\u6ee4\u8c13\u8bcd\u91cd\u65b0\u8868\u8ff0\u539f\u59cb\u9759\u6001\u8fc7\u6ee4\u65b9\u6cd5\uff0c\u5e76\u5c06\u5176\u6269\u5c55\u5230\u56de\u7b54\u96c6\u7f16\u7a0b\uff08ASP\uff09\uff1b\u540c\u65f6\u63d0\u51fa\u590d\u6742\u5ea6\u66f4\u4f4e\u7684\u53ef\u5904\u7406\u8fd1\u4f3c\u7b97\u6cd5\u4ee5\u5e94\u5bf9\u901a\u7528\u65b9\u6cd5\u7684\u9ad8\u8ba1\u7b97\u590d\u6742\u5ea6\u3002", "result": "\u6269\u5c55\u540e\u7684\u9759\u6001\u8fc7\u6ee4\u65b9\u6cd5\u5728\u7406\u8bba\u4e0a\u66f4\u901a\u7528\u4f46\u590d\u6742\u5ea6\u66f4\u9ad8\uff08\u4e00\u822c\u60c5\u51b5\u4e0b\u4e3a\u53cc\u6307\u6570\uff0c\u6709\u754c\u5143\u6570\u4e0b\u4e3a\u5355\u6307\u6570\uff09\uff1b\u6240\u63d0\u51fa\u7684\u8fd1\u4f3c\u7b97\u6cd5\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff08\u5982\u5904\u7406\u771f\u5b9e\u4e16\u754c\u6570\u636e\u7684\u89c4\u5219\u7cfb\u7edf\uff09\u53ef\u5e26\u6765\u6570\u91cf\u7ea7\u7ea7\u522b\u7684\u6027\u80fd\u63d0\u5347\u3002", "conclusion": "\u9759\u6001\u8fc7\u6ee4\u662f\u4e00\u79cd\u88ab\u4f4e\u4f30\u7684\u4f18\u5316\u6280\u672f\uff0c\u901a\u8fc7\u73b0\u4ee3\u5316\u8868\u8ff0\u548c\u8fd1\u4f3c\u7b56\u7565\uff0c\u53ef\u5728\u4fdd\u6301\u5b9e\u7528\u6027\u7684\u540c\u65f6\u663e\u8457\u589e\u5f3aDatalog\u548cASP\u7cfb\u7edf\u7684\u6548\u7387\u3002"}}
